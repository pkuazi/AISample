# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _gjsonc.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_gjsonc')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_gjsonc')
    _gjsonc = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gjsonc', [dirname(__file__)])
        except ImportError:
            import _gjsonc
            return _gjsonc
        try:
            _mod = imp.load_module('_gjsonc', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _gjsonc = swig_import_helper()
    del swig_import_helper
else:
    import _gjsonc
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



'''
	欺骗swig编译器，加载 numpy 的 c 模板函数
'''


'''
	GeoJson 编码压缩模块
'''

class GeoJsonUtils(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def EncodePoints(self, coords: 'PyObject *') -> "PyObject *":
        """对geojson坐标序列进行压缩unicode串"""
        return _gjsonc.GeoJsonUtils_EncodePoints(self, coords)


    def TruncPoints(self, coords: 'PyObject *', tail: 'int') -> "PyObject *":
        """对geojson坐标序列进行小数点位截取"""
        return _gjsonc.GeoJsonUtils_TruncPoints(self, coords, tail)


    def DecodePoints(self, coords: 'PyObject *', prevX: 'int', prevY: 'int') -> "PyObject *":
        """对geojson unicode串进行解压坐标序列"""
        return _gjsonc.GeoJsonUtils_DecodePoints(self, coords, prevX, prevY)


    def __init__(self):
        _gjsonc.GeoJsonUtils_swiginit(self, _gjsonc.new_GeoJsonUtils())
    __swig_destroy__ = _gjsonc.delete_GeoJsonUtils
GeoJsonUtils.EncodePoints = new_instancemethod(_gjsonc.GeoJsonUtils_EncodePoints, None, GeoJsonUtils)
GeoJsonUtils.TruncPoints = new_instancemethod(_gjsonc.GeoJsonUtils_TruncPoints, None, GeoJsonUtils)
GeoJsonUtils.DecodePoints = new_instancemethod(_gjsonc.GeoJsonUtils_DecodePoints, None, GeoJsonUtils)
GeoJsonUtils_swigregister = _gjsonc.GeoJsonUtils_swigregister
GeoJsonUtils_swigregister(GeoJsonUtils)


'''
    geojson 压缩和解压代码
'''

def encode_geojson(geojson):    
    '''
    对geojson坐标序列进行压缩unicode串
    '''
    gtype = geojson["type"].lower()
    coordinates = geojson["coordinates"]

    gju = GeoJsonUtils()    
    new_coordinates = []

    if gtype in ["MultiPolygon".lower()]: 
        for a_polygon in coordinates:
            aline = gju.EncodePoints(a_polygon[0])
            new_coordinates.append([ aline ])       

    elif gtype in ["Polygon".lower(), "MultiLineString".lower()]:   
        for a_polygon in coordinates:
            aline = gju.EncodePoints(a_polygon)
            new_coordinates.append([ aline ])  

    elif gtype in ["LineString".lower()]:      
        aline = gju.EncodePoints(coordinates)    
        new_coordinates = [aline]       

    geojson["coordinates"] = new_coordinates 
    return geojson 


def decode_geojson(geojson):    
    '''
    对geojson unicode串进行解压坐标序列
    '''
    gtype = geojson["type"].lower()
    coordinates = geojson["coordinates"]

    gju = GeoJsonUtils()
    new_coordinates = [] 

    if gtype in ["MultiPolygon".lower()]:   
        for a_polygon in coordinates: 
            a_polygon = a_polygon[0]
            aline = gju.DecodePoints(a_polygon[0], * a_polygon[1])
            new_coordinates.append([ aline ])

    elif gtype in ["Polygon".lower(), "MultiLineString".lower()]:    
        for a_polygon in coordinates: 
            a_polygon = a_polygon[0]
            aline = gju.DecodePoints(a_polygon[0], * a_polygon[1])
            new_coordinates.append(aline) 

    elif gtype in ["LineString".lower()]:    
        coordinates = coordinates[0]
        new_coordinates = gju.DecodePoints(coordinates[0], * coordinates[1])  

    geojson["coordinates"] = new_coordinates 
    return geojson 


def trunc_geojson(geojson, tail):
    '''
    对geojson坐标序列进行小数点位截取
    '''
    gtype = geojson["type"].lower()
    coordinates = geojson["coordinates"] 

    gju = GeoJsonUtils()

    new_coordinates = []
    if gtype in ["MultiPolygon".lower()]: 
        for a_polygon in coordinates: 
            aline = gju.TruncPoints(a_polygon[0], tail)
            new_coordinates.append([ aline ])

    elif gtype in ["Polygon".lower(), "MultiLineString".lower()]:           
        for a_polygon in coordinates: 
            aline = gju.TruncPoints(a_polygon, tail)
            new_coordinates.append(aline)

        geojson["coordinates"] = new_coordinates 

    elif gtype in ["LineString".lower()]:    
        new_coordinates = gju.TruncPoints(coordinates, tail)      

    geojson["coordinates"] = new_coordinates 
    return geojson 


def jsdecode_source():
    '''
    javascript 对geojson unicode串进行解压坐标序列的代码
    '''
    return '''
var GSON = {
    base_number : 100000.0,
    base_offset : 64,
    decode_a_line : function(coordinate, encodeOffsets) {
        var result = [];

        var prevX = encodeOffsets[0]
        var prevY = encodeOffsets[1]

        var l = coordinate.length;
        var i = 0;
        while (i < l) {
            var x = coordinate.charCodeAt(i) - this.base_offset
            var y = coordinate.charCodeAt(i + 1) - this.base_offset
            i += 2;

            x = (x >> 1) ^ (-(x & 1));
            y = (y >> 1) ^ (-(y & 1));

            x += prevX;
            y += prevY;

            prevX = x;
            prevY = y;

            result.push([ x / this.base_number, y / this.base_number ])
        }
        return result;
    }, 

    decode_geojson: function(geojson) {
        var gtype = geojson["type"];
        var coordinates = geojson["coordinates"];       

        var new_coordinates = [];        
        if( gtype == "MultiPolygon" ){ 
            for (var i = 0; i < coordinates.length; i++) {
                var a_polygon = coordinates[i];
                a_polygon = a_polygon[0];
                var aline = this.decode_a_line(a_polygon[0], a_polygon[1]);
                new_coordinates.push([ aline ])
            } 
        }else if ( gtype == "Polygon" || qtype == "MultiLineString" ){
                for (var i = 0; i < coordinates.length; i++) {
                    var a_polygon = coordinates[i];
                    a_polygon = a_polygon[0];
                    var aline = this.decode_a_line(a_polygon[0], a_polygon[1]);
                    new_coordinates.push( aline );
                } 
        } else if ( gtype == "LineString" ){ 
            var coordinates = coordinates[0];
            new_coordinates = this.decode_a_line(a_polygon[0], a_polygon[1]);
        } 

        geojson["coordinates"] = new_coordinates ;
        return geojson  ;
    }
};
'''




